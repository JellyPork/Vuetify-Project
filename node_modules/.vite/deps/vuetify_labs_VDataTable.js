import {
  VTable
} from "./chunk-WHNNHEPW.js";
import {
  VMenuSymbol,
  VOverlay,
  filterVOverlayProps,
  makeVOverlayProps,
  useScopeId
} from "./chunk-WNQJBK36.js";
import {
  VInput,
  VLabel,
  VTextField,
  filterInputProps,
  filterVTextFieldProps,
  makeVInputProps,
  makeVTextFieldProps,
  useFocus,
  useForm
} from "./chunk-33PVW2UV.js";
import {
  forwardRefs
} from "./chunk-ABXCYA5O.js";
import {
  VList,
  VListItem,
  makeItemsProps,
  useItems
} from "./chunk-MAJRUPJO.js";
import "./chunk-UPLVUIPL.js";
import {
  VAvatar
} from "./chunk-RS7MPUCG.js";
import "./chunk-WLTKZFKR.js";
import {
  VBtn,
  makeGroupItemProps,
  makeGroupProps,
  useGroup,
  useGroupItem
} from "./chunk-KD2X2JX7.js";
import "./chunk-RH3CJ37A.js";
import {
  LoaderSlot,
  makeLoaderProps,
  useLoader
} from "./chunk-2MOHQKNY.js";
import {
  VDialogTransition,
  VExpandXTransition
} from "./chunk-F46XYWAG.js";
import {
  Ripple
} from "./chunk-4JMPQBFI.js";
import {
  makeDensityProps,
  useDensity
} from "./chunk-ABZK3XW7.js";
import {
  genOverlays,
  makeVariantProps,
  useVariant
} from "./chunk-3L66ADXH.js";
import {
  VDefaultsProvider
} from "./chunk-4IY6WC3V.js";
import {
  VIcon,
  makeSizeProps,
  useSize
} from "./chunk-OZ3XNSQD.js";
import "./chunk-6WZR6LF4.js";
import "./chunk-RIAEBD2A.js";
import {
  makeTransitionProps
} from "./chunk-SHJNAKAU.js";
import "./chunk-2LREOSGS.js";
import {
  makeRouterProps,
  useLink
} from "./chunk-3FCXWDT2.js";
import {
  makeBorderProps,
  makeElevationProps,
  useBorder,
  useElevation
} from "./chunk-WKWVKVOX.js";
import {
  makeRoundedProps,
  useRounded
} from "./chunk-BBVZ3ZKU.js";
import {
  useBackgroundColor,
  useTextColor
} from "./chunk-Y7I46GY2.js";
import {
  makeTagProps
} from "./chunk-GVFLKG3A.js";
import {
  IconValue
} from "./chunk-VFQUPLLP.js";
import {
  useLocale
} from "./chunk-ETPEIHIH.js";
import {
  useProxiedModel
} from "./chunk-D5DXHR6N.js";
import {
  makeThemeProps,
  provideTheme
} from "./chunk-TILYBLOH.js";
import "./chunk-KUTXRGIM.js";
import {
  EventProp,
  SUPPORTS_FOCUS_VISIBLE,
  convertToUnit,
  createRange,
  deepEqual,
  defineComponent,
  defineFunctionalComponent,
  filterInputAttrs,
  genericComponent,
  getCurrentInstance,
  getObjectValueByPath,
  getPropertyFromItem,
  getUid,
  omit,
  pick,
  propsFactory,
  provideDefaults,
  useRender,
  wrapInArray
} from "./chunk-ZZT3WMJC.js";
import {
  Fragment,
  computed,
  createTextVNode,
  createVNode,
  inject,
  mergeProps,
  nextTick,
  onScopeDispose,
  provide,
  ref,
  resolveDirective,
  toRef,
  unref,
  vShow,
  watch,
  watchEffect,
  withDirectives
} from "./chunk-SE5EWVSA.js";
import "./chunk-RSJERJUL.js";

// node_modules/vuetify/lib/labs/VDataTable/VDataTable.mjs
import "D:/Files/Web/vuetify-project/Vuetify-Project/node_modules/vuetify/lib/labs/VDataTable/VDataTable.css";

// node_modules/vuetify/lib/components/VCheckbox/VCheckbox.mjs
import "D:/Files/Web/vuetify-project/Vuetify-Project/node_modules/vuetify/lib/components/VCheckbox/VCheckbox.css";

// node_modules/vuetify/lib/components/VSelectionControl/VSelectionControl.mjs
import "D:/Files/Web/vuetify-project/Vuetify-Project/node_modules/vuetify/lib/components/VSelectionControl/VSelectionControl.css";

// node_modules/vuetify/lib/components/VSelectionControlGroup/VSelectionControlGroup.mjs
import "D:/Files/Web/vuetify-project/Vuetify-Project/node_modules/vuetify/lib/components/VSelectionControlGroup/VSelectionControlGroup.css";
var VSelectionControlGroupSymbol = Symbol.for("vuetify:selection-control-group");
var makeSelectionControlGroupProps = propsFactory({
  color: String,
  disabled: Boolean,
  error: Boolean,
  id: String,
  inline: Boolean,
  falseIcon: IconValue,
  trueIcon: IconValue,
  ripple: {
    type: Boolean,
    default: true
  },
  multiple: {
    type: Boolean,
    default: null
  },
  name: String,
  readonly: Boolean,
  modelValue: null,
  type: String,
  valueComparator: {
    type: Function,
    default: deepEqual
  },
  ...makeThemeProps(),
  ...makeDensityProps()
}, "v-selection-control-group");
var VSelectionControlGroup = defineComponent({
  name: "VSelectionControlGroup",
  props: {
    defaultsTarget: {
      type: String,
      default: "VSelectionControl"
    },
    ...makeSelectionControlGroupProps()
  },
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const modelValue = useProxiedModel(props, "modelValue");
    const uid = getUid();
    const id = computed(() => props.id || `v-selection-control-group-${uid}`);
    const name = computed(() => props.name || id.value);
    const updateHandlers = /* @__PURE__ */ new Set();
    provide(VSelectionControlGroupSymbol, {
      modelValue,
      forceUpdate: () => {
        updateHandlers.forEach((fn) => fn());
      },
      onForceUpdate: (cb) => {
        updateHandlers.add(cb);
        onScopeDispose(() => {
          updateHandlers.delete(cb);
        });
      }
    });
    provideDefaults({
      [props.defaultsTarget]: {
        color: toRef(props, "color"),
        disabled: toRef(props, "disabled"),
        density: toRef(props, "density"),
        error: toRef(props, "error"),
        inline: toRef(props, "inline"),
        modelValue,
        multiple: computed(() => !!props.multiple || props.multiple == null && Array.isArray(modelValue.value)),
        name,
        falseIcon: toRef(props, "falseIcon"),
        trueIcon: toRef(props, "trueIcon"),
        readonly: toRef(props, "readonly"),
        ripple: toRef(props, "ripple"),
        type: toRef(props, "type"),
        valueComparator: toRef(props, "valueComparator")
      }
    });
    useRender(() => {
      var _slots$default;
      return createVNode("div", {
        "class": ["v-selection-control-group", {
          "v-selection-control-group--inline": props.inline
        }],
        "role": props.type === "radio" ? "radiogroup" : void 0
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]);
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VSelectionControl/VSelectionControl.mjs
var makeSelectionControlProps = propsFactory({
  label: String,
  trueValue: null,
  falseValue: null,
  value: null,
  ...makeSelectionControlGroupProps()
}, "v-selection-control");
function useSelectionControl(props) {
  const group = inject(VSelectionControlGroupSymbol, void 0);
  const {
    densityClasses
  } = useDensity(props);
  const modelValue = useProxiedModel(props, "modelValue");
  const trueValue = computed(() => props.trueValue !== void 0 ? props.trueValue : props.value !== void 0 ? props.value : true);
  const falseValue = computed(() => props.falseValue !== void 0 ? props.falseValue : false);
  const isMultiple = computed(() => !!props.multiple || props.multiple == null && Array.isArray(modelValue.value));
  const model = computed({
    get() {
      const val = group ? group.modelValue.value : modelValue.value;
      return isMultiple.value ? val.some((v) => props.valueComparator(v, trueValue.value)) : props.valueComparator(val, trueValue.value);
    },
    set(val) {
      if (props.readonly)
        return;
      const currentValue = val ? trueValue.value : falseValue.value;
      let newVal = currentValue;
      if (isMultiple.value) {
        newVal = val ? [...wrapInArray(modelValue.value), currentValue] : wrapInArray(modelValue.value).filter((item) => !props.valueComparator(item, trueValue.value));
      }
      if (group) {
        group.modelValue.value = newVal;
      } else {
        modelValue.value = newVal;
      }
    }
  });
  const {
    textColorClasses,
    textColorStyles
  } = useTextColor(computed(() => {
    return model.value && !props.error && !props.disabled ? props.color : void 0;
  }));
  const icon = computed(() => model.value ? props.trueIcon : props.falseIcon);
  return {
    group,
    densityClasses,
    trueValue,
    falseValue,
    model,
    textColorClasses,
    textColorStyles,
    icon
  };
}
var VSelectionControl = genericComponent()({
  name: "VSelectionControl",
  directives: {
    Ripple
  },
  inheritAttrs: false,
  props: makeSelectionControlProps(),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      group,
      densityClasses,
      icon,
      model,
      textColorClasses,
      textColorStyles,
      trueValue
    } = useSelectionControl(props);
    const uid = getUid();
    const id = computed(() => props.id || `input-${uid}`);
    const isFocused = ref(false);
    const isFocusVisible = ref(false);
    const input = ref();
    group == null ? void 0 : group.onForceUpdate(() => {
      if (input.value) {
        input.value.checked = model.value;
      }
    });
    function onFocus(e) {
      isFocused.value = true;
      if (!SUPPORTS_FOCUS_VISIBLE || SUPPORTS_FOCUS_VISIBLE && e.target.matches(":focus-visible")) {
        isFocusVisible.value = true;
      }
    }
    function onBlur() {
      isFocused.value = false;
      isFocusVisible.value = false;
    }
    function onInput(e) {
      if (props.readonly && group) {
        nextTick(() => group.forceUpdate());
      }
      model.value = e.target.checked;
    }
    useRender(() => {
      var _slots$default, _slots$input;
      const label = slots.label ? slots.label({
        label: props.label,
        props: {
          for: id.value
        }
      }) : props.label;
      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
      return createVNode("div", mergeProps({
        "class": ["v-selection-control", {
          "v-selection-control--dirty": model.value,
          "v-selection-control--disabled": props.disabled,
          "v-selection-control--error": props.error,
          "v-selection-control--focused": isFocused.value,
          "v-selection-control--focus-visible": isFocusVisible.value,
          "v-selection-control--inline": props.inline
        }, densityClasses.value]
      }, rootAttrs), [createVNode("div", {
        "class": ["v-selection-control__wrapper", textColorClasses.value],
        "style": textColorStyles.value
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots), withDirectives(createVNode("div", {
        "class": ["v-selection-control__input"]
      }, [icon.value && createVNode(VIcon, {
        "key": "icon",
        "icon": icon.value
      }, null), createVNode("input", mergeProps({
        "ref": input,
        "checked": model.value,
        "disabled": props.disabled,
        "id": id.value,
        "onBlur": onBlur,
        "onFocus": onFocus,
        "onInput": onInput,
        "aria-disabled": props.readonly,
        "type": props.type,
        "value": trueValue.value,
        "name": props.name,
        "aria-checked": props.type === "checkbox" ? model.value : void 0
      }, inputAttrs), null), (_slots$input = slots.input) == null ? void 0 : _slots$input.call(slots, {
        model,
        textColorClasses,
        textColorStyles,
        props: {
          onFocus,
          onBlur,
          id: id.value
        }
      })]), [[resolveDirective("ripple"), props.ripple && [!props.disabled && !props.readonly, null, ["center", "circle"]]]])]), label && createVNode(VLabel, {
        "for": id.value,
        "clickable": true
      }, {
        default: () => [label]
      })]);
    });
    return {
      isFocused,
      input
    };
  }
});

// node_modules/vuetify/lib/components/VCheckbox/VCheckboxBtn.mjs
var makeVCheckboxBtnProps = propsFactory({
  indeterminate: Boolean,
  indeterminateIcon: {
    type: IconValue,
    default: "$checkboxIndeterminate"
  },
  ...makeSelectionControlProps({
    falseIcon: "$checkboxOff",
    trueIcon: "$checkboxOn"
  })
}, "v-checkbox-btn");
var VCheckboxBtn = defineComponent({
  name: "VCheckboxBtn",
  props: makeVCheckboxBtnProps(),
  emits: {
    "update:modelValue": (value) => true,
    "update:indeterminate": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const indeterminate = useProxiedModel(props, "indeterminate");
    const model = useProxiedModel(props, "modelValue");
    function onChange(v) {
      if (indeterminate.value) {
        indeterminate.value = false;
      }
    }
    const falseIcon = computed(() => {
      return props.indeterminate ? props.indeterminateIcon : props.falseIcon;
    });
    const trueIcon = computed(() => {
      return props.indeterminate ? props.indeterminateIcon : props.trueIcon;
    });
    useRender(() => createVNode(VSelectionControl, mergeProps(props, {
      "modelValue": model.value,
      "onUpdate:modelValue": [($event) => model.value = $event, onChange],
      "class": "v-checkbox-btn",
      "type": "checkbox",
      "inline": true,
      "falseIcon": falseIcon.value,
      "trueIcon": trueIcon.value,
      "aria-checked": props.indeterminate ? "mixed" : void 0
    }), slots));
    return {};
  }
});
function filterCheckboxBtnProps(props) {
  return pick(props, Object.keys(VCheckboxBtn.props));
}

// node_modules/vuetify/lib/components/VCheckbox/VCheckbox.mjs
var VCheckbox = defineComponent({
  name: "VCheckbox",
  inheritAttrs: false,
  props: {
    ...makeVInputProps(),
    ...makeVCheckboxBtnProps()
  },
  emits: {
    "update:focused": (focused) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      isFocused,
      focus,
      blur
    } = useFocus(props);
    const uid = getUid();
    const id = computed(() => props.id || `checkbox-${uid}`);
    useRender(() => {
      const [inputAttrs, controlAttrs] = filterInputAttrs(attrs);
      const [inputProps, _1] = filterInputProps(props);
      const [checkboxProps, _2] = filterCheckboxBtnProps(props);
      return createVNode(VInput, mergeProps({
        "class": "v-checkbox"
      }, inputAttrs, inputProps, {
        "id": id.value,
        "focused": isFocused.value
      }), {
        ...slots,
        default: (_ref2) => {
          let {
            id: id2,
            messagesId,
            isDisabled,
            isReadonly
          } = _ref2;
          return createVNode(VCheckboxBtn, mergeProps(checkboxProps, {
            "id": id2.value,
            "aria-describedby": messagesId.value,
            "disabled": isDisabled.value,
            "readonly": isReadonly.value
          }, controlAttrs, {
            "onFocus": focus,
            "onBlur": blur
          }), slots);
        }
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VDataTable/VDataTableColumn.mjs
var VDataTableColumn = defineFunctionalComponent({
  align: {
    type: String,
    default: "start"
  },
  fixed: Boolean,
  fixedOffset: [Number, String],
  height: [Number, String],
  lastFixed: Boolean,
  noPadding: Boolean,
  tag: String,
  width: [Number, String]
}, (props, _ref) => {
  var _a;
  var _slots$default;
  let {
    slots,
    attrs
  } = _ref;
  const Tag = (_a = props.tag) != null ? _a : "td";
  return createVNode(Tag, mergeProps({
    "class": ["v-data-table__td", {
      "v-data-table-column--fixed": props.fixed,
      "v-data-table-column--last-fixed": props.lastFixed,
      "v-data-table-column--no-padding": props.noPadding
    }, `v-data-table-column--align-${props.align}`],
    "style": {
      height: convertToUnit(props.height),
      width: convertToUnit(props.width),
      left: convertToUnit(props.fixedOffset || null)
    }
  }, attrs), {
    default: () => [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]
  });
});

// node_modules/vuetify/lib/labs/VDataTable/composables/headers.mjs
var makeDataTableHeaderProps = propsFactory({
  headers: {
    type: Array,
    default: () => []
  }
}, "v-data-table-header");
var VDataTableHeadersSymbol = Symbol.for("vuetify:data-table-headers");
function createHeaders(props, options) {
  const headers = ref([]);
  const columns = ref([]);
  watch(() => props.headers, () => {
    var _a;
    var _options$groupBy, _options$showSelect, _options$showExpand;
    const wrapped = !props.headers.length ? [] : Array.isArray(props.headers[0]) ? props.headers : [props.headers];
    const flat = wrapped.flatMap((row, index) => row.map((column) => ({
      column,
      row: index
    })));
    const rowCount = wrapped.length;
    const defaultHeader = {
      title: "",
      sortable: false
    };
    const defaultActionHeader = {
      ...defaultHeader,
      width: 48
    };
    if (options != null && (_options$groupBy = options.groupBy) != null && _options$groupBy.value.length) {
      const index = flat.findIndex((_ref) => {
        let {
          column
        } = _ref;
        return column.key === "data-table-group";
      });
      if (index < 0)
        flat.unshift({
          column: {
            ...defaultHeader,
            key: "data-table-group",
            title: "Group",
            rowspan: rowCount
          },
          row: 0
        });
      else
        flat.splice(index, 1, {
          column: {
            ...defaultHeader,
            ...flat[index].column
          },
          row: flat[index].row
        });
    }
    if (options != null && (_options$showSelect = options.showSelect) != null && _options$showSelect.value) {
      const index = flat.findIndex((_ref2) => {
        let {
          column
        } = _ref2;
        return column.key === "data-table-select";
      });
      if (index < 0)
        flat.unshift({
          column: {
            ...defaultActionHeader,
            key: "data-table-select",
            rowspan: rowCount
          },
          row: 0
        });
      else
        flat.splice(index, 1, {
          column: {
            ...defaultActionHeader,
            ...flat[index].column
          },
          row: flat[index].row
        });
    }
    if (options != null && (_options$showExpand = options.showExpand) != null && _options$showExpand.value) {
      const index = flat.findIndex((_ref3) => {
        let {
          column
        } = _ref3;
        return column.key === "data-table-expand";
      });
      if (index < 0)
        flat.push({
          column: {
            ...defaultActionHeader,
            key: "data-table-expand",
            rowspan: rowCount
          },
          row: 0
        });
      else
        flat.splice(index, 1, {
          column: {
            ...defaultActionHeader,
            ...flat[index].column
          },
          row: flat[index].row
        });
    }
    const fixedRows = createRange(rowCount).map(() => []);
    const fixedOffsets = createRange(rowCount).fill(0);
    let count = 0;
    flat.forEach((_ref4) => {
      var _a2, _b, _c, _d;
      let {
        column,
        row
      } = _ref4;
      const id = (_a2 = column.key) != null ? _a2 : `data-table-column-${count++}`;
      for (let i = row; i <= row + ((_b = column.rowspan) != null ? _b : 1) - 1; i++) {
        fixedRows[i].push({
          ...column,
          key: id,
          fixedOffset: fixedOffsets[i],
          sortable: (_c = column.sortable) != null ? _c : !!column.key
        });
        fixedOffsets[i] += (_d = column.width) != null ? _d : 0;
      }
    });
    fixedRows.forEach((row) => {
      for (let i = row.length; i--; i >= 0) {
        if (row[i].fixed) {
          row[i].lastFixed = true;
          return;
        }
      }
    });
    const seen = /* @__PURE__ */ new Set();
    headers.value = fixedRows.map((row) => {
      const filtered = [];
      for (const column of row) {
        if (!seen.has(column.key)) {
          seen.add(column.key);
          filtered.push(column);
        }
      }
      return filtered;
    });
    columns.value = (_a = fixedRows.at(-1)) != null ? _a : [];
  }, {
    deep: true,
    immediate: true
  });
  const data = {
    headers,
    columns
  };
  provide(VDataTableHeadersSymbol, data);
  return data;
}
function useHeaders() {
  const data = inject(VDataTableHeadersSymbol);
  if (!data)
    throw new Error("Missing headers!");
  return data;
}

// node_modules/vuetify/lib/labs/VDataTable/composables/select.mjs
var makeDataTableSelectProps = propsFactory({
  showSelect: Boolean,
  modelValue: {
    type: Array,
    default: () => []
  }
}, "v-data-table-select");
var VDataTableSelectionSymbol = Symbol.for("vuetify:data-table-selection");
function createSelection(props, allItems) {
  const selected = useProxiedModel(props, "modelValue", props.modelValue, (v) => {
    return new Set(v);
  }, (v) => {
    return [...v.values()];
  });
  function isSelected(items) {
    return items.every((item) => selected.value.has(item.value));
  }
  function isSomeSelected(items) {
    return items.some((item) => selected.value.has(item.value));
  }
  function select(items, value) {
    const newSelected = new Set(selected.value);
    for (const item of items) {
      if (value)
        newSelected.add(item.value);
      else
        newSelected.delete(item.value);
    }
    selected.value = newSelected;
  }
  function toggleSelect(item) {
    select([item], !isSelected([item]));
  }
  function selectAll(value) {
    select(allItems.value, value);
  }
  const someSelected = computed(() => selected.value.size > 0);
  const allSelected = computed(() => isSelected(allItems.value));
  const data = {
    toggleSelect,
    select,
    selectAll,
    isSelected,
    isSomeSelected,
    someSelected,
    allSelected
  };
  provide(VDataTableSelectionSymbol, data);
  return data;
}
function useSelection() {
  const data = inject(VDataTableSelectionSymbol);
  if (!data)
    throw new Error("Missing selection!");
  return data;
}

// node_modules/vuetify/lib/labs/VDataTable/composables/sort.mjs
var makeDataTableSortProps = propsFactory({
  sortBy: {
    type: Array,
    default: () => []
  },
  multiSort: Boolean,
  mustSort: Boolean
}, "v-data-table-sort");
var VDataTableSortSymbol = Symbol.for("vuetify:data-table-sort");
function createSort(props) {
  const sortBy = useProxiedModel(props, "sortBy");
  const toggleSort = (key) => {
    var _a;
    let newSortBy = (_a = sortBy.value.map((x) => ({
      ...x
    }))) != null ? _a : [];
    const item = newSortBy.find((x) => x.key === key);
    if (!item) {
      if (props.multiSort)
        newSortBy = [...newSortBy, {
          key,
          order: "asc"
        }];
      else
        newSortBy = [{
          key,
          order: "asc"
        }];
    } else if (item.order === "desc") {
      if (props.mustSort) {
        item.order = "asc";
      } else {
        newSortBy = newSortBy.filter((x) => x.key !== key);
      }
    } else {
      item.order = "desc";
    }
    sortBy.value = newSortBy;
  };
  const data = {
    sortBy,
    toggleSort
  };
  provide(VDataTableSortSymbol, data);
  return data;
}
function useSort() {
  const data = inject(VDataTableSortSymbol);
  if (!data)
    throw new Error("Missing sort!");
  return data;
}
function useSortedItems(items, sortBy, columns) {
  const customSorters = computed(() => {
    return columns.value.reduce((obj, item) => {
      if (item.sort)
        obj[item.key] = item.sort;
      return obj;
    }, {});
  });
  const sortedItems = computed(() => {
    if (!sortBy.value.length)
      return items.value;
    return sortItems(items.value, sortBy.value, "en", customSorters.value);
  });
  return {
    sortedItems
  };
}
function sortItems(items, sortByItems, locale, customSorters) {
  const stringCollator = new Intl.Collator(locale, {
    sensitivity: "accent",
    usage: "sort"
  });
  return [...items].sort((a, b) => {
    for (let i = 0; i < sortByItems.length; i++) {
      const sortKey = sortByItems[i].key;
      const sortOrder = sortByItems[i].order;
      if (sortOrder === false)
        continue;
      let sortA = getObjectValueByPath(a.raw, sortKey);
      let sortB = getObjectValueByPath(b.raw, sortKey);
      if (sortOrder === "desc") {
        [sortA, sortB] = [sortB, sortA];
      }
      if (customSorters != null && customSorters[sortKey]) {
        const customResult = customSorters[sortKey](sortA, sortB);
        if (!customResult)
          continue;
        return customResult;
      }
      if (sortA == null || sortB == null) {
        continue;
      }
      if (sortA instanceof Date && sortB instanceof Date) {
        return sortA.getTime() - sortB.getTime();
      }
      [sortA, sortB] = [sortA, sortB].map((s) => (s || "").toString().toLocaleLowerCase());
      if (sortA !== sortB) {
        if (!isNaN(sortA) && !isNaN(sortB))
          return Number(sortA) - Number(sortB);
        return stringCollator.compare(sortA, sortB);
      }
    }
    return 0;
  });
}

// node_modules/vuetify/lib/labs/VDataTable/VDataTableHeaders.mjs
var VDataTableHeaders = defineComponent({
  name: "VDataTableHeaders",
  props: {
    color: String,
    sticky: Boolean,
    multiSort: Boolean,
    sortAscIcon: {
      type: IconValue,
      default: "$sortAsc"
    },
    sortDescIcon: {
      type: IconValue,
      default: "$sortDesc"
    },
    ...makeLoaderProps()
  },
  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const {
      toggleSort,
      sortBy
    } = useSort();
    const {
      someSelected,
      allSelected,
      selectAll
    } = useSelection();
    const {
      columns,
      headers
    } = useHeaders();
    const {
      loaderClasses
    } = useLoader(props);
    const getFixedStyles = (column, y) => {
      if (!props.sticky && !column.fixed)
        return null;
      return {
        position: "sticky",
        zIndex: column.fixed ? 4 : props.sticky ? 3 : void 0,
        left: column.fixed ? convertToUnit(column.fixedOffset) : void 0,
        top: props.sticky ? `calc(var(--v-table-header-height) * ${y})` : void 0
      };
    };
    function getSortIcon(id) {
      const item = sortBy.value.find((item2) => item2.key === id);
      if (!item)
        return props.sortAscIcon;
      return item.order === "asc" ? props.sortAscIcon : props.sortDescIcon;
    }
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(props, "color");
    const VDataTableHeaderCell = (_ref2) => {
      let {
        column,
        x,
        y
      } = _ref2;
      const isSorted = !!sortBy.value.find((x2) => x2.key === column.key);
      const noPadding = column.key === "data-table-select" || column.key === "data-table-expand";
      return createVNode(VDataTableColumn, {
        "tag": "th",
        "align": column.align,
        "class": ["v-data-table__th", {
          "v-data-table__th--sortable": column.sortable,
          "v-data-table__th--sorted": isSorted
        }, loaderClasses.value],
        "style": {
          width: convertToUnit(column.width),
          minWidth: convertToUnit(column.width),
          ...getFixedStyles(column, y)
        },
        "colspan": column.colspan,
        "rowspan": column.rowspan,
        "onClick": column.sortable ? () => toggleSort(column.key) : void 0,
        "lastFixed": column.lastFixed,
        "noPadding": noPadding
      }, {
        default: () => {
          var _a;
          const slotName = `column.${column.key}`;
          const slotProps = {
            column,
            selectAll
          };
          if (slots[slotName])
            return slots[slotName](slotProps);
          if (column.key === "data-table-select") {
            var _slots$columnDataTa;
            return (_a = (_slots$columnDataTa = slots["column.data-table-select"]) == null ? void 0 : _slots$columnDataTa.call(slots, slotProps)) != null ? _a : createVNode(VCheckboxBtn, {
              "modelValue": allSelected.value,
              "indeterminate": someSelected.value && !allSelected.value,
              "onUpdate:modelValue": selectAll
            }, null);
          }
          return createVNode("div", {
            "class": "v-data-table-header__content"
          }, [createVNode("span", null, [column.title]), column.sortable && createVNode(VIcon, {
            "key": "icon",
            "class": "v-data-table-header__sort-icon",
            "icon": getSortIcon(column.key)
          }, null), props.multiSort && isSorted && createVNode("div", {
            "key": "badge",
            "class": ["v-data-table-header__sort-badge", ...backgroundColorClasses.value],
            "style": backgroundColorStyles.value
          }, [sortBy.value.findIndex((x2) => x2.key === column.key) + 1])]);
        }
      });
    };
    useRender(() => createVNode(Fragment, null, [headers.value.map((row, y) => createVNode("tr", null, [row.map((column, x) => createVNode(VDataTableHeaderCell, {
      "column": column,
      "x": x,
      "y": y
    }, null))])), props.loading && createVNode("tr", {
      "class": "v-data-table__progress"
    }, [createVNode("th", {
      "colspan": columns.value.length
    }, [createVNode(LoaderSlot, {
      "name": "v-data-table-headers",
      "active": true,
      "color": typeof props.loading === "boolean" ? void 0 : props.loading,
      "indeterminate": true
    }, {
      default: slots.loader
    })])])]));
  }
});

// node_modules/vuetify/lib/labs/VDataTable/composables/group.mjs
var makeDataTableGroupProps = propsFactory({
  groupBy: {
    type: Array,
    default: () => []
  }
}, "data-table-group");
var VDataTableGroupSymbol = Symbol.for("vuetify:data-table-group");
function createGroupBy(props, groupBy, sortBy) {
  const opened = ref(/* @__PURE__ */ new Set());
  const sortByWithGroups = computed(() => {
    return groupBy.value.map((val) => {
      var _a;
      return {
        ...val,
        order: (_a = val.order) != null ? _a : false
      };
    }).concat(sortBy.value);
  });
  function isGroupOpen(group) {
    return opened.value.has(group.id);
  }
  function toggleGroup(group) {
    const newOpened = new Set(opened.value);
    if (!isGroupOpen(group))
      newOpened.add(group.id);
    else
      newOpened.delete(group.id);
    opened.value = newOpened;
  }
  function extractRows(items) {
    function dive(group) {
      const arr = [];
      for (const item of group.items) {
        if (item.type === "item")
          arr.push(item);
        else {
          arr.push(...dive(item));
        }
      }
      return arr;
    }
    return dive({
      type: "group-header",
      items,
      id: "dummy",
      key: "dummy",
      value: "dummy",
      depth: 0
    });
  }
  const data = {
    sortByWithGroups,
    toggleGroup,
    opened,
    groupBy,
    extractRows,
    isGroupOpen
  };
  provide(VDataTableGroupSymbol, data);
  return data;
}
function useGroupBy() {
  const data = inject(VDataTableGroupSymbol);
  if (!data)
    throw new Error("Missing group!");
  return data;
}
function groupItemsByProperty(items, groupBy) {
  if (!items.length)
    return [];
  const groups = /* @__PURE__ */ new Map();
  for (const item of items) {
    const value = getObjectValueByPath(item.raw, groupBy);
    if (!groups.has(value)) {
      groups.set(value, []);
    }
    groups.get(value).push(item);
  }
  return groups;
}
function groupItems(items, groupBy) {
  let depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  let prefix = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "root";
  if (!groupBy.length)
    return [];
  const groupedItems = groupItemsByProperty(items, groupBy[0]);
  const groups = [];
  const rest = groupBy.slice(1);
  groupedItems.forEach((items2, value) => {
    const key = groupBy[0];
    const id = `${prefix}_${key}_${value}`;
    groups.push({
      depth,
      id,
      key,
      value,
      items: rest.length ? groupItems(items2, rest, depth + 1, id) : items2,
      type: "group-header"
    });
  });
  return groups;
}
function flattenItems(items, opened) {
  const flatItems = [];
  for (const item of items) {
    if (item.type === "group-header") {
      if (item.value != null) {
        flatItems.push(item);
      }
      if (opened.has(item.id) || item.value == null) {
        flatItems.push(...flattenItems(item.items, opened));
      }
    } else {
      flatItems.push(item);
    }
  }
  return flatItems;
}
function useGroupedItems(items, groupBy, opened) {
  const flatItems = computed(() => {
    if (!groupBy.value.length)
      return items.value;
    const groupedItems = groupItems(items.value, groupBy.value.map((item) => item.key));
    return flattenItems(groupedItems, opened.value);
  });
  return {
    flatItems
  };
}

// node_modules/vuetify/lib/labs/VDataTable/VDataTableGroupHeaderRow.mjs
var VDataTableGroupHeaderRow = defineComponent({
  name: "VDataTableGroupHeaderRow",
  props: {
    item: {
      type: Object,
      required: true
    }
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      isGroupOpen,
      toggleGroup,
      extractRows
    } = useGroupBy();
    const {
      isSelected,
      isSomeSelected,
      select
    } = useSelection();
    const {
      columns
    } = useHeaders();
    const rows = computed(() => {
      return extractRows([props.item]);
    });
    return () => createVNode("tr", {
      "class": "v-data-table-group-header-row",
      "style": {
        "--v-data-table-group-header-row-depth": props.item.depth
      }
    }, [columns.value.map((column) => {
      var _a, _b;
      if (column.key === "data-table-group") {
        var _slots$dataTableGro;
        const icon = isGroupOpen(props.item) ? "$expand" : "$next";
        const onClick = () => toggleGroup(props.item);
        return (_a = (_slots$dataTableGro = slots["data-table-group"]) == null ? void 0 : _slots$dataTableGro.call(slots, {
          item: props.item,
          count: rows.value.length,
          props: {
            icon,
            onClick
          }
        })) != null ? _a : createVNode(VDataTableColumn, {
          "class": "v-data-table-group-header-row__column"
        }, {
          default: () => [createVNode(VBtn, {
            "size": "small",
            "variant": "text",
            "icon": icon,
            "onClick": onClick
          }, null), createVNode("span", null, [props.item.value]), createVNode("span", null, [createTextVNode("("), rows.value.length, createTextVNode(")")])]
        });
      }
      if (column.key === "data-table-select") {
        var _slots$dataTableSel;
        const modelValue = isSelected(rows.value);
        const indeterminate = isSomeSelected(rows.value) && !modelValue;
        const selectGroup = (v) => select(rows.value, v);
        return (_b = (_slots$dataTableSel = slots["data-table-select"]) == null ? void 0 : _slots$dataTableSel.call(slots, {
          props: {
            modelValue,
            indeterminate,
            "onUpdate:modelValue": selectGroup
          }
        })) != null ? _b : createVNode("td", null, [createVNode(VCheckboxBtn, {
          "modelValue": modelValue,
          "indeterminate": indeterminate,
          "onUpdate:modelValue": selectGroup
        }, null)]);
      }
      return createVNode("td", null, null);
    })]);
  }
});

// node_modules/vuetify/lib/labs/VDataTable/composables/expand.mjs
var makeDataTableExpandProps = propsFactory({
  expandOnClick: Boolean,
  showExpand: Boolean,
  expanded: {
    type: Array,
    default: () => []
  }
}, "v-data-table-expand");
var VDataTableExpandedKey = Symbol.for("vuetify:datatable:expanded");
function createExpanded(props) {
  const expandOnClick = toRef(props, "expandOnClick");
  const expanded = useProxiedModel(props, "expanded", props.expanded, (v) => {
    return new Set(v);
  }, (v) => {
    return [...v.values()];
  });
  function expand(item, value) {
    const newExpanded = new Set(expanded.value);
    if (!value) {
      newExpanded.delete(item.value);
    } else {
      newExpanded.add(item.value);
    }
    expanded.value = newExpanded;
  }
  function isExpanded(item) {
    return expanded.value.has(item.value);
  }
  function toggleExpand(item) {
    expand(item, !isExpanded(item));
  }
  const data = {
    expand,
    expanded,
    expandOnClick,
    isExpanded,
    toggleExpand
  };
  provide(VDataTableExpandedKey, data);
  return data;
}
function useExpanded() {
  const data = inject(VDataTableExpandedKey);
  if (!data)
    throw new Error("foo");
  return data;
}

// node_modules/vuetify/lib/labs/VDataTable/VDataTableRow.mjs
var VDataTableRow = defineComponent({
  name: "VDataTableRow",
  props: {
    item: Object
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      isSelected,
      toggleSelect
    } = useSelection();
    const {
      isExpanded,
      toggleExpand
    } = useExpanded();
    const {
      columns
    } = useHeaders();
    useRender(() => createVNode("tr", {
      "class": ["v-data-table__tr"]
    }, [!columns.value.length && createVNode(VDataTableColumn, {
      "key": "no-data"
    }, slots), props.item && columns.value.map((column, i) => createVNode(VDataTableColumn, {
      "align": column.align,
      "fixed": column.fixed,
      "fixedOffset": column.fixedOffset,
      "lastFixed": column.lastFixed,
      "noPadding": column.key === "data-table-select" || column.key === "data-table-expand",
      "width": column.width
    }, {
      default: () => {
        var _a, _b;
        const item = props.item;
        const slotName = `item.${column.key}`;
        const slotProps = {
          item: props.item,
          columns: columns.value,
          isSelected,
          toggleSelect,
          isExpanded,
          toggleExpand
        };
        if (slots[slotName])
          return slots[slotName](slotProps);
        if (column.key === "data-table-select") {
          var _slots$itemDataTabl;
          return (_a = (_slots$itemDataTabl = slots["item.data-table-select"]) == null ? void 0 : _slots$itemDataTabl.call(slots, slotProps)) != null ? _a : createVNode(VCheckboxBtn, {
            "modelValue": isSelected([item]),
            "onClick": () => toggleSelect(item)
          }, null);
        }
        if (column.key === "data-table-expand") {
          var _slots$itemDataTabl2;
          return (_b = (_slots$itemDataTabl2 = slots["item.data-table-expand"]) == null ? void 0 : _slots$itemDataTabl2.call(slots, slotProps)) != null ? _b : createVNode(VBtn, {
            "icon": isExpanded(item) ? "$collapse" : "$expand",
            "size": "small",
            "variant": "text",
            "onClick": () => toggleExpand(item)
          }, null);
        }
        return item.columns[column.key];
      }
    }))]));
  }
});

// node_modules/vuetify/lib/labs/VDataTable/VDataTableRows.mjs
var VDataTableRows = defineComponent({
  name: "VDataTableRows",
  props: {
    loading: [Boolean, String],
    loadingText: {
      type: String,
      default: "$vuetify.dataIterator.loadingText"
    },
    hideNoData: Boolean,
    items: {
      type: Array,
      default: () => []
    },
    noDataText: {
      type: String,
      default: "$vuetify.noDataText"
    },
    rowHeight: Number
  },
  emits: {
    "click:row": (event, value) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const {
      columns
    } = useHeaders();
    const {
      expandOnClick,
      toggleExpand,
      isExpanded
    } = useExpanded();
    const {
      isSelected,
      toggleSelect
    } = useSelection();
    const {
      toggleGroup,
      isGroupOpen
    } = useGroupBy();
    const {
      t
    } = useLocale();
    useRender(() => {
      var _a, _b;
      var _slots$loading, _slots$noData;
      return createVNode(Fragment, null, [props.loading ? (_a = (_slots$loading = slots.loading) == null ? void 0 : _slots$loading.call(slots)) != null ? _a : createVNode(VDataTableRow, {
        "class": "v-data-table-rows-no-data",
        "key": "loading"
      }, {
        default: () => [t(props.loadingText)]
      }) : void 0, !props.loading && !props.items.length && !props.hideNoData && ((_b = (_slots$noData = slots["no-data"]) == null ? void 0 : _slots$noData.call(slots)) != null ? _b : createVNode(VDataTableRow, {
        "class": "v-data-table-rows-no-data",
        "key": "no-data"
      }, {
        default: () => [t(props.noDataText)]
      })), props.items.map((item, index) => {
        var _slots$expandedRow;
        if (item.type === "group-header") {
          return slots["group-header"] ? slots["group-header"]({
            index,
            item,
            columns: columns.value,
            isExpanded,
            toggleExpand,
            isSelected,
            toggleSelect,
            toggleGroup,
            isGroupOpen
          }) : createVNode(VDataTableGroupHeaderRow, {
            "key": `group-header_${item.id}`,
            "item": item
          }, slots);
        }
        return createVNode(Fragment, null, [slots.item ? slots.item({
          index,
          item,
          columns: columns.value,
          isExpanded,
          toggleExpand,
          isSelected,
          toggleSelect
        }) : createVNode(VDataTableRow, {
          "key": `item_${item.value}`,
          "onClick": (event) => {
            if (expandOnClick.value) {
              toggleExpand(item.value);
            }
            emit("click:row", event, {
              item
            });
          },
          "item": item
        }, slots), isExpanded(item) && ((_slots$expandedRow = slots["expanded-row"]) == null ? void 0 : _slots$expandedRow.call(slots, {
          item,
          columns: columns.value
        }))]);
      })]);
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VDataTable/VDataTableFooter.mjs
import "D:/Files/Web/vuetify-project/Vuetify-Project/node_modules/vuetify/lib/labs/VDataTable/VDataTableFooter.css";

// node_modules/vuetify/lib/components/VSelect/VSelect.mjs
import "D:/Files/Web/vuetify-project/Vuetify-Project/node_modules/vuetify/lib/components/VSelect/VSelect.css";

// node_modules/vuetify/lib/components/VChip/VChip.mjs
import "D:/Files/Web/vuetify-project/Vuetify-Project/node_modules/vuetify/lib/components/VChip/VChip.css";

// node_modules/vuetify/lib/components/VChipGroup/VChipGroup.mjs
import "D:/Files/Web/vuetify-project/Vuetify-Project/node_modules/vuetify/lib/components/VChipGroup/VChipGroup.css";
var VChipGroupSymbol = Symbol.for("vuetify:v-chip-group");
var VChipGroup = defineComponent({
  name: "VChipGroup",
  props: {
    column: Boolean,
    filter: Boolean,
    valueComparator: {
      type: Function,
      default: deepEqual
    },
    ...makeGroupProps({
      selectedClass: "v-chip--selected"
    }),
    ...makeTagProps(),
    ...makeThemeProps(),
    ...makeVariantProps({
      variant: "tonal"
    })
  },
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      isSelected,
      select,
      next,
      prev,
      selected
    } = useGroup(props, VChipGroupSymbol);
    provideDefaults({
      VChip: {
        color: toRef(props, "color"),
        disabled: toRef(props, "disabled"),
        filter: toRef(props, "filter"),
        variant: toRef(props, "variant")
      }
    });
    useRender(() => {
      var _slots$default;
      return createVNode(props.tag, {
        "class": ["v-chip-group", {
          "v-chip-group--column": props.column
        }, themeClasses.value]
      }, {
        default: () => [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
          isSelected,
          select,
          next,
          prev,
          selected: selected.value
        })]
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VChip/VChip.mjs
var VChip = defineComponent({
  name: "VChip",
  directives: {
    Ripple
  },
  props: {
    activeClass: String,
    appendAvatar: String,
    appendIcon: IconValue,
    closable: Boolean,
    closeIcon: {
      type: IconValue,
      default: "$delete"
    },
    closeLabel: {
      type: String,
      default: "$vuetify.close"
    },
    draggable: Boolean,
    filter: Boolean,
    filterIcon: {
      type: String,
      default: "$complete"
    },
    label: Boolean,
    link: {
      type: Boolean,
      default: void 0
    },
    pill: Boolean,
    prependAvatar: String,
    prependIcon: IconValue,
    ripple: {
      type: Boolean,
      default: true
    },
    text: String,
    modelValue: {
      type: Boolean,
      default: true
    },
    onClick: EventProp,
    onClickOnce: EventProp,
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeElevationProps(),
    ...makeGroupItemProps(),
    ...makeRoundedProps(),
    ...makeRouterProps(),
    ...makeSizeProps(),
    ...makeTagProps({
      tag: "span"
    }),
    ...makeThemeProps(),
    ...makeVariantProps({
      variant: "tonal"
    })
  },
  emits: {
    "click:close": (e) => true,
    "update:modelValue": (value) => true,
    "group:selected": (val) => true,
    click: (e) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      emit,
      slots
    } = _ref;
    const {
      borderClasses
    } = useBorder(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props);
    const {
      densityClasses
    } = useDensity(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      sizeClasses
    } = useSize(props);
    const {
      themeClasses
    } = provideTheme(props);
    const isActive = useProxiedModel(props, "modelValue");
    const group = useGroupItem(props, VChipGroupSymbol, false);
    const link = useLink(props, attrs);
    const isLink = computed(() => props.link !== false && link.isLink.value);
    const isClickable = computed(() => !props.disabled && props.link !== false && (!!group || props.link || link.isClickable.value));
    function onCloseClick(e) {
      isActive.value = false;
      emit("click:close", e);
    }
    function onClick(e) {
      var _link$navigate;
      emit("click", e);
      if (!isClickable.value)
        return;
      (_link$navigate = link.navigate) == null ? void 0 : _link$navigate.call(link, e);
      group == null ? void 0 : group.toggle();
    }
    function onKeyDown(e) {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        onClick(e);
      }
    }
    return () => {
      var _slots$default;
      const Tag = link.isLink.value ? "a" : props.tag;
      const hasAppend = !!(slots.append || props.appendIcon || props.appendAvatar);
      const hasClose = !!(slots.close || props.closable);
      const hasFilter = !!(slots.filter || props.filter) && group;
      const hasPrepend = !!(slots.prepend || props.prependIcon || props.prependAvatar);
      const hasColor = !group || group.isSelected.value;
      return isActive.value && withDirectives(createVNode(Tag, {
        "class": ["v-chip", {
          "v-chip--disabled": props.disabled,
          "v-chip--label": props.label,
          "v-chip--link": isClickable.value,
          "v-chip--filter": hasFilter,
          "v-chip--pill": props.pill
        }, themeClasses.value, borderClasses.value, hasColor ? colorClasses.value : void 0, densityClasses.value, elevationClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, group == null ? void 0 : group.selectedClass.value],
        "style": [hasColor ? colorStyles.value : void 0],
        "disabled": props.disabled || void 0,
        "draggable": props.draggable,
        "href": link.href.value,
        "tabindex": isClickable.value ? 0 : void 0,
        "onClick": onClick,
        "onKeydown": isClickable.value && !isLink.value && onKeyDown
      }, {
        default: () => {
          var _a;
          return [genOverlays(isClickable.value, "v-chip"), hasFilter && createVNode(VDefaultsProvider, {
            "key": "filter",
            "defaults": {
              VIcon: {
                icon: props.filterIcon
              }
            }
          }, {
            default: () => [createVNode(VExpandXTransition, null, {
              default: () => [withDirectives(createVNode("div", {
                "class": "v-chip__filter"
              }, [slots.filter ? slots.filter() : createVNode(VIcon, null, null)]), [[vShow, group.isSelected.value]])]
            })]
          }), hasPrepend && createVNode(VDefaultsProvider, {
            "key": "prepend",
            "defaults": {
              VAvatar: {
                image: props.prependAvatar
              },
              VIcon: {
                icon: props.prependIcon
              }
            }
          }, {
            default: () => [slots.prepend ? createVNode("div", {
              "class": "v-chip__prepend"
            }, [slots.prepend()]) : props.prependAvatar ? createVNode(VAvatar, {
              "start": true
            }, null) : props.prependIcon ? createVNode(VIcon, {
              "start": true
            }, null) : void 0]
          }), (_a = (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
            isSelected: group == null ? void 0 : group.isSelected.value,
            selectedClass: group == null ? void 0 : group.selectedClass.value,
            select: group == null ? void 0 : group.select,
            toggle: group == null ? void 0 : group.toggle,
            value: group == null ? void 0 : group.value.value,
            disabled: props.disabled
          })) != null ? _a : props.text, hasAppend && createVNode(VDefaultsProvider, {
            "key": "append",
            "defaults": {
              VAvatar: {
                image: props.appendAvatar
              },
              VIcon: {
                icon: props.appendIcon
              }
            }
          }, {
            default: () => [slots.append ? createVNode("div", {
              "class": "v-chip__append"
            }, [slots.append()]) : props.appendAvatar ? createVNode(VAvatar, {
              "end": true
            }, null) : props.appendIcon ? createVNode(VIcon, {
              "end": true
            }, null) : void 0]
          }), hasClose && createVNode(VDefaultsProvider, {
            "key": "close",
            "defaults": {
              VIcon: {
                icon: props.closeIcon,
                size: "x-small"
              }
            }
          }, {
            default: () => [createVNode("div", {
              "class": "v-chip__close",
              "onClick": onCloseClick
            }, [slots.close ? slots.close() : createVNode(VIcon, null, null)])]
          })];
        }
      }), [[resolveDirective("ripple"), isClickable.value && props.ripple, null]]);
    };
  }
});

// node_modules/vuetify/lib/components/VMenu/VMenu.mjs
import "D:/Files/Web/vuetify-project/Vuetify-Project/node_modules/vuetify/lib/components/VMenu/VMenu.css";
var VMenu = genericComponent()({
  name: "VMenu",
  props: {
    id: String,
    ...omit(makeVOverlayProps({
      closeDelay: 250,
      closeOnContentClick: true,
      locationStrategy: "connected",
      openDelay: 300,
      scrim: false,
      scrollStrategy: "reposition",
      transition: {
        component: VDialogTransition
      }
    }), ["absolute"])
  },
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const isActive = useProxiedModel(props, "modelValue");
    const {
      scopeId
    } = useScopeId();
    const uid = getUid();
    const id = computed(() => props.id || `v-menu-${uid}`);
    const overlay = ref();
    const parent = inject(VMenuSymbol, null);
    let openChildren = 0;
    provide(VMenuSymbol, {
      register() {
        ++openChildren;
      },
      unregister() {
        --openChildren;
      },
      closeParents() {
        setTimeout(() => {
          if (!openChildren) {
            isActive.value = false;
            parent == null ? void 0 : parent.closeParents();
          }
        }, 40);
      }
    });
    watch(isActive, (val) => {
      val ? parent == null ? void 0 : parent.register() : parent == null ? void 0 : parent.unregister();
    });
    function onClickOutside() {
      parent == null ? void 0 : parent.closeParents();
    }
    const activatorProps = computed(() => mergeProps({
      "aria-haspopup": "menu",
      "aria-expanded": String(isActive.value),
      "aria-owns": id.value
    }, props.activatorProps));
    useRender(() => {
      const [overlayProps] = filterVOverlayProps(props);
      return createVNode(VOverlay, mergeProps({
        "ref": overlay,
        "class": ["v-menu"]
      }, overlayProps, {
        "modelValue": isActive.value,
        "onUpdate:modelValue": ($event) => isActive.value = $event,
        "absolute": true,
        "activatorProps": activatorProps.value,
        "onClick:outside": onClickOutside
      }, scopeId), {
        activator: slots.activator,
        default: function() {
          var _slots$default;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createVNode(VDefaultsProvider, {
            "root": true
          }, {
            default: () => [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, ...args)]
          });
        }
      });
    });
    return forwardRefs({
      id
    }, overlay);
  }
});

// node_modules/vuetify/lib/components/VSelect/VSelect.mjs
var makeSelectProps = propsFactory({
  chips: Boolean,
  closableChips: Boolean,
  eager: Boolean,
  hideNoData: Boolean,
  hideSelected: Boolean,
  menu: Boolean,
  menuIcon: {
    type: IconValue,
    default: "$dropdown"
  },
  menuProps: {
    type: Object
  },
  multiple: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  openOnClear: Boolean,
  valueComparator: {
    type: Function,
    default: deepEqual
  },
  ...makeItemsProps({
    itemChildren: false
  })
}, "v-select");
var VSelect = genericComponent()({
  name: "VSelect",
  props: {
    ...makeSelectProps(),
    ...omit(makeVTextFieldProps({
      modelValue: null
    }), ["validationValue", "dirty", "appendInnerIcon"]),
    ...makeTransitionProps({
      transition: {
        component: VDialogTransition
      }
    })
  },
  emits: {
    "update:modelValue": (val) => true,
    "update:menu": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const menu = useProxiedModel(props, "menu");
    const {
      items,
      transformIn,
      transformOut
    } = useItems(props);
    const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(wrapInArray(v)), (v) => {
      var _a;
      const transformed = transformOut(v);
      return props.multiple ? transformed : (_a = transformed[0]) != null ? _a : null;
    });
    const form = useForm();
    const selections = computed(() => {
      return model.value.map((v) => {
        return items.value.find((item) => props.valueComparator(item.value, v.value)) || v;
      });
    });
    const selected = computed(() => selections.value.map((selection) => selection.props.value));
    const displayItems = computed(() => {
      if (props.hideSelected) {
        return items.value.filter((item) => !selections.value.some((s) => s === item));
      }
      return items.value;
    });
    const listRef = ref();
    function onClear(e) {
      model.value = [];
      if (props.openOnClear) {
        menu.value = true;
      }
    }
    function onClickControl() {
      if (props.hideNoData && !items.value.length || props.readonly || form != null && form.isReadonly.value)
        return;
      menu.value = !menu.value;
    }
    function onKeydown(e) {
      if (props.readonly || form != null && form.isReadonly.value)
        return;
      if (["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"].includes(e.key)) {
        e.preventDefault();
      }
      if (["Enter", "ArrowDown", " "].includes(e.key)) {
        menu.value = true;
      }
      if (["Escape", "Tab"].includes(e.key)) {
        menu.value = false;
      }
      if (e.key === "ArrowDown") {
        var _listRef$value;
        (_listRef$value = listRef.value) == null ? void 0 : _listRef$value.focus("next");
      } else if (e.key === "ArrowUp") {
        var _listRef$value2;
        (_listRef$value2 = listRef.value) == null ? void 0 : _listRef$value2.focus("prev");
      } else if (e.key === "Home") {
        var _listRef$value3;
        (_listRef$value3 = listRef.value) == null ? void 0 : _listRef$value3.focus("first");
      } else if (e.key === "End") {
        var _listRef$value4;
        (_listRef$value4 = listRef.value) == null ? void 0 : _listRef$value4.focus("last");
      }
    }
    function select(item) {
      if (props.multiple) {
        const index = selected.value.findIndex((selection) => props.valueComparator(selection, item.value));
        if (index === -1) {
          model.value = [...model.value, item];
        } else {
          const value = [...model.value];
          value.splice(index, 1);
          model.value = value;
        }
      } else {
        model.value = [item];
        menu.value = false;
      }
    }
    function onBlur(e) {
      var _listRef$value5;
      if (!((_listRef$value5 = listRef.value) != null && _listRef$value5.$el.contains(e.relatedTarget))) {
        menu.value = false;
      }
    }
    function onFocusout(e) {
      if (e.relatedTarget == null) {
        var _vTextFieldRef$value;
        (_vTextFieldRef$value = vTextFieldRef.value) == null ? void 0 : _vTextFieldRef$value.focus();
      }
    }
    useRender(() => {
      const hasChips = !!(props.chips || slots.chip);
      const hasList = !!(!props.hideNoData || displayItems.value.length || slots.prepend || slots.append || slots["no-data"]);
      const [textFieldProps] = filterVTextFieldProps(props);
      return createVNode(VTextField, mergeProps({
        "ref": vTextFieldRef
      }, textFieldProps, {
        "modelValue": model.value.map((v) => v.props.value).join(", "),
        "onUpdate:modelValue": (v) => {
          if (v == null)
            model.value = [];
        },
        "validationValue": model.externalValue,
        "dirty": model.value.length > 0,
        "class": ["v-select", {
          "v-select--active-menu": menu.value,
          "v-select--chips": !!props.chips,
          [`v-select--${props.multiple ? "multiple" : "single"}`]: true,
          "v-select--selected": model.value.length
        }],
        "appendInnerIcon": props.menuIcon,
        "readonly": true,
        "onClick:clear": onClear,
        "onClick:control": onClickControl,
        "onBlur": onBlur,
        "onKeydown": onKeydown
      }), {
        ...slots,
        default: () => {
          var _slots$noData, _slots$prependItem, _slots$appendItem;
          return createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
            "modelValue": menu.value,
            "onUpdate:modelValue": ($event) => menu.value = $event,
            "activator": "parent",
            "contentClass": "v-select__content",
            "eager": props.eager,
            "maxHeight": 310,
            "openOnClick": false,
            "closeOnContentClick": false,
            "transition": props.transition
          }, props.menuProps), {
            default: () => [hasList && createVNode(VList, {
              "ref": listRef,
              "selected": selected.value,
              "selectStrategy": props.multiple ? "independent" : "single-independent",
              "onMousedown": (e) => e.preventDefault(),
              "onFocusout": onFocusout
            }, {
              default: () => {
                var _a;
                return [!displayItems.value.length && !props.hideNoData && ((_a = (_slots$noData = slots["no-data"]) == null ? void 0 : _slots$noData.call(slots)) != null ? _a : createVNode(VListItem, {
                  "title": t(props.noDataText)
                }, null)), (_slots$prependItem = slots["prepend-item"]) == null ? void 0 : _slots$prependItem.call(slots), displayItems.value.map((item, index) => {
                  if (slots.item) {
                    var _slots$item;
                    return (_slots$item = slots.item) == null ? void 0 : _slots$item.call(slots, {
                      item,
                      index,
                      props: mergeProps(item.props, {
                        onClick: () => select(item)
                      })
                    });
                  }
                  return createVNode(VListItem, mergeProps({
                    "key": index
                  }, item.props, {
                    "onClick": () => select(item)
                  }), {
                    prepend: (_ref2) => {
                      let {
                        isSelected
                      } = _ref2;
                      return props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                        "modelValue": isSelected,
                        "ripple": false
                      }, null) : void 0;
                    }
                  });
                }), (_slots$appendItem = slots["append-item"]) == null ? void 0 : _slots$appendItem.call(slots)];
              }
            })]
          }), selections.value.map((item, index) => {
            function onChipClose(e) {
              e.stopPropagation();
              e.preventDefault();
              select(item);
            }
            const slotProps = {
              "onClick:close": onChipClose,
              modelValue: true,
              "onUpdate:modelValue": void 0
            };
            return createVNode("div", {
              "key": item.value,
              "class": "v-select__selection"
            }, [hasChips ? createVNode(VDefaultsProvider, {
              "defaults": {
                VChip: {
                  closable: props.closableChips,
                  size: "small",
                  text: item.title
                }
              }
            }, {
              default: () => [slots.chip ? slots.chip({
                item,
                index,
                props: slotProps
              }) : createVNode(VChip, slotProps, null)]
            }) : slots.selection ? slots.selection({
              item,
              index
            }) : createVNode("span", {
              "class": "v-select__selection-text"
            }, [item.title, props.multiple && index < selections.value.length - 1 && createVNode("span", {
              "class": "v-select__selection-comma"
            }, [createTextVNode(",")])])]);
          })]);
        }
      });
    });
    return forwardRefs({
      menu,
      select
    }, vTextFieldRef);
  }
});

// node_modules/vuetify/lib/labs/VDataTable/composables/paginate.mjs
var makeDataTablePaginateProps = propsFactory({
  page: {
    type: [Number, String],
    default: 1
  },
  itemsPerPage: {
    type: [Number, String],
    default: 10
  }
}, "v-data-table-paginate");
var VDataTablePaginationSymbol = Symbol.for("vuetify:data-table-pagination");
function createPagination(props, items) {
  const page = useProxiedModel(props, "page", void 0, (value) => +(value != null ? value : 1));
  const itemsPerPage = useProxiedModel(props, "itemsPerPage", void 0, (value) => +(value != null ? value : 10));
  const itemsLength = computed(() => {
    var _a;
    return +((_a = props.itemsLength) != null ? _a : items.value.length);
  });
  const startIndex = computed(() => {
    if (itemsPerPage.value === -1)
      return 0;
    return itemsPerPage.value * (page.value - 1);
  });
  const stopIndex = computed(() => {
    if (itemsPerPage.value === -1)
      return itemsLength.value;
    return Math.min(itemsLength.value, startIndex.value + itemsPerPage.value);
  });
  const pageCount = computed(() => {
    if (itemsPerPage.value === -1)
      return 1;
    return Math.ceil(itemsLength.value / itemsPerPage.value);
  });
  watchEffect(() => {
    if (startIndex.value > itemsLength.value) {
      page.value = 1;
    }
  });
  const data = {
    page,
    itemsPerPage,
    startIndex,
    stopIndex,
    pageCount,
    itemsLength
  };
  provide(VDataTablePaginationSymbol, data);
  return data;
}
function usePagination() {
  const data = inject(VDataTablePaginationSymbol);
  if (!data)
    throw new Error("Missing pagination!");
  return data;
}
function usePaginatedItems(items, startIndex, stopIndex, itemsPerPage) {
  const paginatedItems = computed(() => {
    if (itemsPerPage.value <= 0)
      return items.value;
    return items.value.slice(startIndex.value, stopIndex.value);
  });
  return {
    paginatedItems
  };
}

// node_modules/vuetify/lib/labs/VDataTable/VDataTableFooter.mjs
var VDataTableFooter = defineComponent({
  name: "VDataTableFooter",
  props: {
    prevIcon: {
      type: String,
      default: "$prev"
    },
    nextIcon: {
      type: String,
      default: "$next"
    },
    firstIcon: {
      type: String,
      default: "$first"
    },
    lastIcon: {
      type: String,
      default: "$last"
    },
    itemsPerPageOptions: {
      type: Array,
      default: () => [{
        value: 10,
        title: "10"
      }, {
        value: 25,
        title: "25"
      }, {
        value: 50,
        title: "50"
      }, {
        value: 100,
        title: "100"
      }, {
        value: -1,
        title: "All"
      }]
    },
    showCurrentPage: Boolean
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      page,
      pageCount,
      startIndex,
      stopIndex,
      itemsLength,
      itemsPerPage
    } = usePagination();
    return () => {
      var _a, _b, _c;
      var _slots$prepend;
      return createVNode("div", {
        "class": "v-data-table-footer"
      }, [(_slots$prepend = slots.prepend) == null ? void 0 : _slots$prepend.call(slots), createVNode("div", {
        "class": "v-data-table-footer__items-per-page"
      }, [createVNode("span", null, [createTextVNode("Items per page:")]), createVNode(VSelect, {
        "items": props.itemsPerPageOptions,
        "modelValue": itemsPerPage.value,
        "onUpdate:modelValue": (v) => itemsPerPage.value = Number(v),
        "density": "compact",
        "variant": "outlined",
        "hide-details": true
      }, null)]), createVNode("div", {
        "class": "v-data-table-footer__info"
      }, [createVNode("div", null, [((_a = startIndex.value) != null ? _a : -1) + 1, createTextVNode(" - "), (_b = stopIndex.value) != null ? _b : 0, createTextVNode(" of "), (_c = itemsLength.value) != null ? _c : 0])]), createVNode("div", {
        "class": "v-data-table-footer__pagination"
      }, [createVNode(VBtn, {
        "icon": props.firstIcon,
        "variant": "plain",
        "onClick": () => page.value = 1,
        "disabled": page.value === 1
      }, null), createVNode(VBtn, {
        "icon": props.prevIcon,
        "variant": "plain",
        "onClick": () => page.value = Math.max(1, page.value - 1),
        "disabled": page.value === 1
      }, null), props.showCurrentPage && createVNode("div", {
        "key": "page"
      }, [createTextVNode("page.value")]), createVNode(VBtn, {
        "icon": props.nextIcon,
        "variant": "plain",
        "onClick": () => page.value = Math.min(pageCount.value, page.value + 1),
        "disabled": page.value === pageCount.value
      }, null), createVNode(VBtn, {
        "icon": props.lastIcon,
        "variant": "plain",
        "onClick": () => page.value = pageCount.value,
        "disabled": page.value === pageCount.value
      }, null)])]);
    };
  }
});

// node_modules/vuetify/lib/labs/VDataTable/composables/items.mjs
var makeDataTableItemProps = propsFactory({
  ...makeItemsProps({
    itemValue: "id"
  })
}, "v-data-table-item");
function useDataTableItems(props, columns) {
  const {
    items
  } = useItems(props);
  const dataTableItems = computed(() => items.value.map((item) => {
    return {
      ...item,
      type: "item",
      columns: columns.value.reduce((obj, column) => {
        var _a;
        obj[column.key] = getPropertyFromItem(item.raw, (_a = column.value) != null ? _a : column.key);
        return obj;
      }, {})
    };
  }));
  return {
    items: dataTableItems
  };
}

// node_modules/vuetify/lib/labs/VDataTable/composables/options.mjs
function useOptions(_ref) {
  let {
    page,
    itemsPerPage,
    sortBy,
    startIndex,
    stopIndex,
    pageCount,
    groupBy
  } = _ref;
  const vm = getCurrentInstance("VDataTable");
  const options = computed(() => ({
    page: page.value,
    itemsPerPage: itemsPerPage.value,
    startIndex: startIndex.value,
    stopIndex: stopIndex.value,
    pageCount: pageCount.value,
    sortBy: sortBy.value,
    groupBy: groupBy.value
  }));
  watch(sortBy, () => {
    page.value = 1;
  }, {
    deep: true
  });
  watch(itemsPerPage, () => {
    page.value = 1;
  });
  let oldOptions = null;
  watch(options, () => {
    if (deepEqual(oldOptions, options.value))
      return;
    vm.emit("update:options", options.value);
    oldOptions = options.value;
  }, {
    deep: true,
    immediate: true
  });
}

// node_modules/vuetify/lib/composables/filter.mjs
var defaultFilter = (value, query, item) => {
  if (value == null || query == null)
    return -1;
  return value.toString().toLocaleLowerCase().indexOf(query.toString().toLocaleLowerCase());
};
var makeFilterProps = propsFactory({
  customFilter: Function,
  customKeyFilter: Object,
  filterKeys: [Array, String],
  filterMode: {
    type: String,
    default: "intersection"
  },
  noFilter: Boolean
}, "filter");
function filterItems(items, query, options) {
  var _a, _b;
  const array = [];
  const filter = (_a = options == null ? void 0 : options.default) != null ? _a : defaultFilter;
  const keys = options != null && options.filterKeys ? wrapInArray(options.filterKeys) : false;
  const customFiltersLength = Object.keys((_b = options == null ? void 0 : options.customKeyFilter) != null ? _b : {}).length;
  if (!(items != null && items.length))
    return array;
  loop:
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const customMatches = {};
      const defaultMatches = {};
      let match = -1;
      if (query && !(options != null && options.noFilter)) {
        if (typeof item === "object") {
          const filterKeys = keys || Object.keys(item);
          for (const key of filterKeys) {
            var _options$customKeyFil;
            const value = getPropertyFromItem(item, key, item);
            const keyFilter = options == null ? void 0 : (_options$customKeyFil = options.customKeyFilter) == null ? void 0 : _options$customKeyFil[key];
            match = keyFilter ? keyFilter(value, query, item) : filter(value, query, item);
            if (match !== -1 && match !== false) {
              if (keyFilter)
                customMatches[key] = match;
              else
                defaultMatches[key] = match;
            } else if ((options == null ? void 0 : options.filterMode) === "every") {
              continue loop;
            }
          }
        } else {
          match = filter(item, query, item);
          if (match !== -1 && match !== false) {
            defaultMatches.title = match;
          }
        }
        const defaultMatchesLength = Object.keys(defaultMatches).length;
        const customMatchesLength = Object.keys(customMatches).length;
        if (!defaultMatchesLength && !customMatchesLength)
          continue;
        if ((options == null ? void 0 : options.filterMode) === "union" && customMatchesLength !== customFiltersLength && !defaultMatchesLength)
          continue;
        if ((options == null ? void 0 : options.filterMode) === "intersection" && (customMatchesLength !== customFiltersLength || !defaultMatchesLength))
          continue;
      }
      array.push({
        index: i,
        matches: {
          ...defaultMatches,
          ...customMatches
        }
      });
    }
  return array;
}
function useFilter(props, items, query, options) {
  const strQuery = computed(() => typeof (query == null ? void 0 : query.value) !== "string" && typeof (query == null ? void 0 : query.value) !== "number" ? "" : String(query.value));
  const filteredItems = ref([]);
  const filteredMatches = ref(/* @__PURE__ */ new Map());
  watchEffect(() => {
    var _a;
    filteredItems.value = [];
    filteredMatches.value = /* @__PURE__ */ new Map();
    const transformedItems = unref(items);
    const results = filterItems(transformedItems, strQuery.value, {
      customKeyFilter: props.customKeyFilter,
      default: props.customFilter,
      filterKeys: (_a = unref(options == null ? void 0 : options.filterKeys)) != null ? _a : props.filterKeys,
      filterMode: props.filterMode,
      noFilter: props.noFilter
    });
    results.forEach((_ref) => {
      let {
        index,
        matches
      } = _ref;
      const item = transformedItems[index];
      filteredItems.value.push(item);
      filteredMatches.value.set(item.value, matches);
    });
  });
  function getMatches(item) {
    return filteredMatches.value.get(item.value);
  }
  return {
    filteredItems,
    filteredMatches,
    getMatches
  };
}

// node_modules/vuetify/lib/labs/VDataTable/VDataTable.mjs
var makeVDataTableProps = propsFactory({
  ...makeDataTableItemProps(),
  ...makeDataTableHeaderProps(),
  hideNoData: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  height: [String, Number],
  width: [String, Number],
  fixedHeader: Boolean,
  fixedFooter: Boolean
}, "v-data-table");
var VDataTable = defineComponent({
  name: "VDataTable",
  props: {
    search: String,
    ...makeVDataTableProps(),
    ...makeDataTableExpandProps(),
    ...makeDataTableGroupProps(),
    ...makeDataTableSelectProps(),
    ...makeDataTableSortProps(),
    ...makeDataTablePaginateProps(),
    ...makeFilterProps()
  },
  emits: {
    "update:modelValue": (value) => true,
    "update:page": (value) => true,
    "update:itemsPerPage": (value) => true,
    "update:sortBy": (value) => true,
    "update:options": (value) => true,
    "update:groupBy": (value) => true,
    "update:expanded": (value) => true,
    "click:row": (event, value) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const groupBy = useProxiedModel(props, "groupBy");
    const {
      columns
    } = createHeaders(props, {
      groupBy,
      showSelect: toRef(props, "showSelect"),
      showExpand: toRef(props, "showExpand")
    });
    const {
      items
    } = useDataTableItems(props, columns);
    const filterKeys = computed(() => columns.value.map((c) => "columns." + c.key));
    const {
      filteredItems
    } = useFilter(props, items, toRef(props, "search"), {
      filterKeys
    });
    const {
      sortBy
    } = createSort(props);
    const {
      sortByWithGroups,
      opened,
      extractRows
    } = createGroupBy(props, groupBy, sortBy);
    const {
      sortedItems
    } = useSortedItems(filteredItems, sortByWithGroups, columns);
    const {
      flatItems
    } = useGroupedItems(sortedItems, groupBy, opened);
    const {
      page,
      itemsPerPage,
      startIndex,
      stopIndex,
      pageCount
    } = createPagination(props, flatItems);
    const {
      paginatedItems
    } = usePaginatedItems(flatItems, startIndex, stopIndex, itemsPerPage);
    const paginatedItemsWithoutGroups = computed(() => extractRows(paginatedItems.value));
    createSelection(props, paginatedItemsWithoutGroups);
    createExpanded(props);
    useOptions({
      page,
      itemsPerPage,
      sortBy,
      pageCount,
      startIndex,
      stopIndex,
      groupBy
    });
    provideDefaults({
      VDataTableRows: {
        hideNoData: toRef(props, "hideNoData"),
        noDataText: toRef(props, "noDataText")
      }
    });
    useRender(() => {
      var _a, _b;
      return createVNode(VTable, {
        "class": ["v-data-table", {
          "v-data-table--show-select": props.showSelect
        }],
        "fixedHeader": props.fixedHeader,
        "fixedFooter": props.fixedFooter,
        "height": props.height
      }, {
        top: slots.top,
        default: (_a = slots.default) != null ? _a : () => {
          var _slots$colgroup, _slots$thead, _slots$tbody, _slots$tfoot;
          return createVNode(Fragment, null, [(_slots$colgroup = slots.colgroup) == null ? void 0 : _slots$colgroup.call(slots, {
            columns
          }), createVNode("thead", null, [slots.headers ? slots.headers() : createVNode(VDataTableHeaders, {
            "sticky": props.fixedHeader,
            "multiSort": props.multiSort
          }, slots)]), (_slots$thead = slots.thead) == null ? void 0 : _slots$thead.call(slots), createVNode("tbody", null, [slots.body ? slots.body() : createVNode(VDataTableRows, {
            "items": paginatedItems.value,
            "onClick:row": (event, value) => emit("click:row", event, value)
          }, slots)]), (_slots$tbody = slots.tbody) == null ? void 0 : _slots$tbody.call(slots), (_slots$tfoot = slots.tfoot) == null ? void 0 : _slots$tfoot.call(slots)]);
        },
        bottom: (_b = slots.bottom) != null ? _b : () => createVNode(VDataTableFooter, null, {
          prepend: slots["footer.prepend"]
        })
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VDataTable/composables/virtual.mjs
var makeDataTableVirtualProps = propsFactory({
  visibleItems: {
    type: [String, Number],
    default: 20
  },
  itemHeight: {
    type: [String, Number],
    default: 52
  }
}, "virtual");
var UP = -1;
var DOWN = 1;
function useVirtual(props, items) {
  const startIndex = ref(0);
  const itemHeight = computed(() => parseInt(props.itemHeight, 10));
  const visibleItems = computed(() => parseInt(props.visibleItems, 10));
  const containerRef = ref();
  const isScrolling = ref(false);
  function calculateOffset(index) {
    return index * itemHeight.value;
  }
  function calculateMidPointIndex(scrollTop) {
    let start = 0;
    let end = items.value.length;
    while (start <= end) {
      const middle = start + Math.floor((end - start) / 2);
      const middleOffset = calculateOffset(middle);
      if (middleOffset === scrollTop) {
        return middle;
      } else if (middleOffset < scrollTop) {
        start = middle + 1;
      } else if (middleOffset > scrollTop) {
        end = middle - 1;
      }
    }
    return start;
  }
  let lastScrollTop = 0;
  let scrollTimeout;
  function handleScroll() {
    if (!containerRef.value)
      return;
    isScrolling.value = true;
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => {
      isScrolling.value = false;
    }, 100);
    const scrollTop = containerRef.value.scrollTop;
    const direction = scrollTop < lastScrollTop ? UP : DOWN;
    const midPointIndex = calculateMidPointIndex(scrollTop);
    const buffer = Math.round(visibleItems.value / 3);
    if (direction === UP && midPointIndex <= startIndex.value) {
      startIndex.value = Math.max(midPointIndex - buffer, 0);
    } else if (direction === DOWN && midPointIndex >= startIndex.value + buffer * 2) {
      startIndex.value = Math.min(Math.max(0, midPointIndex - buffer), items.value.length - visibleItems.value);
    }
    lastScrollTop = containerRef.value.scrollTop;
  }
  const stopIndex = computed(() => Math.min(items.value.length, startIndex.value + visibleItems.value));
  const paddingTop = computed(() => calculateOffset(startIndex.value));
  const paddingBottom = computed(() => calculateOffset(items.value.length) - calculateOffset(stopIndex.value));
  return {
    startIndex,
    stopIndex,
    paddingTop,
    paddingBottom,
    handleScroll,
    containerRef,
    itemHeight,
    isScrolling
  };
}

// node_modules/vuetify/lib/labs/VDataTable/VDataTableVirtual.mjs
var VDataTableVirtual = defineComponent({
  name: "VDataTableVirtual",
  props: {
    search: String,
    ...makeVDataTableProps(),
    ...makeVDataTableProps(),
    ...makeDataTableGroupProps(),
    ...makeDataTableExpandProps(),
    ...makeDataTableHeaderProps(),
    ...makeDataTableItemProps(),
    ...makeDataTableSelectProps(),
    ...makeDataTableSortProps(),
    ...makeDataTableVirtualProps(),
    ...makeFilterProps()
  },
  emits: {
    "update:modelValue": (value) => true,
    "update:sortBy": (value) => true,
    "update:options": (value) => true,
    "update:groupBy": (value) => true,
    "update:expanded": (value) => true,
    "click:row": (event, value) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const groupBy = useProxiedModel(props, "groupBy");
    const {
      columns
    } = createHeaders(props, {
      groupBy,
      showSelect: toRef(props, "showSelect"),
      showExpand: toRef(props, "showExpand")
    });
    const {
      items
    } = useDataTableItems(props, columns);
    const filterKeys = computed(() => columns.value.map((c) => "columns." + c.key));
    const {
      filteredItems
    } = useFilter(props, items, toRef(props, "search"), {
      filterKeys
    });
    const {
      sortBy
    } = createSort(props);
    const {
      sortByWithGroups,
      opened,
      extractRows
    } = createGroupBy(props, groupBy, sortBy);
    const {
      sortedItems
    } = useSortedItems(filteredItems, sortByWithGroups, columns);
    const {
      flatItems
    } = useGroupedItems(sortedItems, groupBy, opened);
    const allRows = computed(() => extractRows(flatItems.value));
    createSelection(props, allRows);
    createExpanded(props);
    const {
      containerRef,
      paddingTop,
      paddingBottom,
      startIndex,
      stopIndex,
      itemHeight,
      handleScroll
    } = useVirtual(props, flatItems);
    const visibleItems = computed(() => {
      return flatItems.value.slice(startIndex.value, stopIndex.value);
    });
    useOptions({
      sortBy,
      page: ref(1),
      startIndex: ref(0),
      stopIndex: computed(() => flatItems.value.length - 1),
      pageCount: ref(1),
      itemsPerPage: ref(-1),
      groupBy
    });
    provideDefaults({
      VDataTableRows: {
        hideNoData: toRef(props, "hideNoData"),
        noDataText: toRef(props, "noDataText")
      }
    });
    useRender(() => createVNode(VTable, {
      "class": "v-data-table",
      "style": {
        "--v-table-row-height": convertToUnit(itemHeight.value)
      },
      "height": props.height,
      "fixedHeader": props.fixedHeader
    }, {
      top: slots.top,
      wrapper: () => createVNode("div", {
        "ref": containerRef,
        "onScroll": handleScroll,
        "class": "v-table__wrapper",
        "style": {
          height: convertToUnit(props.height)
        }
      }, [createVNode("table", null, [createVNode("thead", null, [createVNode(VDataTableHeaders, {
        "sticky": props.fixedHeader,
        "multiSort": props.multiSort
      }, slots)]), createVNode("tbody", null, [createVNode("tr", {
        "style": {
          height: convertToUnit(paddingTop.value),
          border: 0
        }
      }, [createVNode("td", {
        "colspan": columns.value.length,
        "style": {
          height: convertToUnit(paddingTop.value),
          border: 0
        }
      }, null)]), createVNode(VDataTableRows, {
        "items": visibleItems.value,
        "onClick:row": (event, value) => emit("click:row", event, value)
      }, slots), createVNode("tr", {
        "style": {
          height: convertToUnit(paddingBottom.value),
          border: 0
        }
      }, [createVNode("td", {
        "colspan": columns.value.length,
        "style": {
          height: convertToUnit(paddingBottom.value),
          border: 0
        }
      }, null)])])])]),
      bottom: slots.bottom
    }));
  }
});

// node_modules/vuetify/lib/labs/VDataTable/VDataTableServer.mjs
var VDataTableServer = defineComponent({
  name: "VDataTableServer",
  props: {
    color: String,
    loading: [Boolean, String],
    loadingText: {
      type: String,
      default: "$vuetify.dataIterator.loadingText"
    },
    itemsLength: [Number, String],
    ...makeVDataTableProps(),
    ...makeDataTableExpandProps(),
    ...makeDataTableHeaderProps(),
    ...makeDataTableItemProps(),
    ...makeDataTableSelectProps(),
    ...makeDataTableSortProps(),
    ...makeDataTablePaginateProps(),
    ...makeDataTableGroupProps()
  },
  emits: {
    "update:modelValue": (value) => true,
    "update:page": (page) => true,
    "update:itemsPerPage": (page) => true,
    "update:sortBy": (sortBy) => true,
    "update:options": (options) => true,
    "update:expanded": (options) => true,
    "update:groupBy": (value) => true,
    "click:row": (event, value) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const groupBy = useProxiedModel(props, "groupBy");
    createExpanded(props);
    const {
      columns
    } = createHeaders(props, {
      groupBy,
      showSelect: toRef(props, "showSelect"),
      showExpand: toRef(props, "showExpand")
    });
    const {
      items
    } = useDataTableItems(props, columns);
    const {
      sortBy,
      toggleSort
    } = createSort(props);
    const {
      opened
    } = createGroupBy(props, groupBy, sortBy);
    const {
      page,
      itemsPerPage,
      startIndex,
      stopIndex,
      pageCount
    } = createPagination(props, items);
    const {
      flatItems
    } = useGroupedItems(items, groupBy, opened);
    createSelection(props, items);
    useOptions({
      page,
      itemsPerPage,
      sortBy,
      startIndex,
      stopIndex,
      pageCount,
      groupBy
    });
    provide("v-data-table", {
      toggleSort,
      sortBy
    });
    provideDefaults({
      VDataTableRows: {
        hideNoData: toRef(props, "hideNoData"),
        noDataText: toRef(props, "noDataText"),
        loading: toRef(props, "loading"),
        loadingText: toRef(props, "loadingText")
      }
    });
    useRender(() => {
      var _a, _b;
      return createVNode(VTable, {
        "class": ["v-data-table", {
          "v-data-table--loading": props.loading
        }],
        "fixedHeader": props.fixedHeader,
        "fixedFooter": props.fixedFooter,
        "height": props.height
      }, {
        top: slots.top,
        default: (_a = slots.default) != null ? _a : () => {
          var _slots$thead, _slots$tbody, _slots$tfoot;
          return createVNode(Fragment, null, [createVNode("thead", {
            "class": "v-data-table__thead",
            "role": "rowgroup"
          }, [slots.headers ? slots.headers() : createVNode(VDataTableHeaders, {
            "sticky": props.fixedHeader,
            "loading": props.loading,
            "color": props.color
          }, null)]), (_slots$thead = slots.thead) == null ? void 0 : _slots$thead.call(slots), createVNode("tbody", {
            "class": "v-data-table__tbody",
            "role": "rowgroup"
          }, [slots.body ? slots.body() : createVNode(VDataTableRows, {
            "items": flatItems.value,
            "onClick:row": (event, value) => emit("click:row", event, value)
          }, slots)]), (_slots$tbody = slots.tbody) == null ? void 0 : _slots$tbody.call(slots), (_slots$tfoot = slots.tfoot) == null ? void 0 : _slots$tfoot.call(slots)]);
        },
        bottom: (_b = slots.bottom) != null ? _b : () => createVNode(VDataTableFooter, null, {
          prepend: slots["footer.prepend"]
        })
      });
    });
  }
});
export {
  VDataTable,
  VDataTableRow,
  VDataTableRows,
  VDataTableServer,
  VDataTableVirtual
};
//# sourceMappingURL=vuetify_labs_VDataTable.js.map
